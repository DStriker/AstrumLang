package MyApp.Main;

import System.Application.Collections /*as Coll*/;
type IFace = System.Application.IInterface;

main: ()
{
	/*extern externalFunc: (a: i32, b: str) -> str;
	ii := k := l := 15;
	j :i64 = void;
	//x[2] += 15;
	//x[3] += k;
	LOCAL_CONSTANT :== 120;
	&ri := ii;
	let &rj := l;
	//forward j := rj;

	unsafe {
		type Test = Test1.Test2.TestClass;
		tc: Test111;
		ic:*Test1.Test2.TestClass= tc&;
		volatile ic2 :*Test = ic;
		gjf: cstring;
		s1: std.string.iterator;
		cb:= (*void).unsafeNarrowToPointer(123456u);
		//globalVar2 = 5;
		if (ic == tc&) ic2*.x.x = 245;
		print(ic2*.x.x);
	}
	getClass2 := ttt.getClass2(4,5);
	//result := ss.sum(400i64);
	vv: Vector3(2,3,4);
	print(Test1.Test2.TestClass.makeTestClass(3,3.14f).getClassExt(c=4,b=2,a=1,b2=true).x);
	ss:=300;
	v: Vector3 = {2,7,4};
	v = {6,53,9};
	print(v.y);
	fv: Vector3 = v;
	x, y, z := fv;
	print(fv.ToString());
	print(fv.HashCode());
	Vector3.setCount(30);
	Vector3.Count = 30;
	vcc: ConcreteVectorClass;
	vc :ConcreteVectorClass= 15;
	print(vc.Name);
	print(vc.Count);
	print(vc.getX());
	print(VectorClass.BYTES);*/
	//nxtm: IInterface? = new ConcreteVectorClass(1,2,3);
	nxtm :IInterface? = new ConcreteVectorClass(11,12,13);
	nxt :IInterface? = nxtm;
	//nxxx: VectorClass?;
	{
		nxt2:VectorClass? = stackalloc ConcreteVectorClass(10,"123455555555");
		vec: Vector3 = new Vector3(12,"12344444444444");
		xxn:= vec.getNext();
		print(nxt2!.GetStrongReferenceCount());
		print(nxt!.GetStrongReferenceCount());
		print(nxt2!.GetStrongReferenceCount());
		print(nxt![2]);
		xx: IInterface.SomeInt = IInterface.VERSION;
		print(xx);
		//print(nxt2![2.5f,3.4f]);
		print(nxt2!.GetStrongReferenceCount());
		//nxxx = nxt2;
		nxt?.Reset();
		print(nxt2!.PrintInterface(123));
		print(nxt!.Name);
		print(sizeof(__Class_ConcreteVectorClass));
		//nxt = null;
		print(nxt2!.GetStrongReferenceCount());
		//print(map<int,map<int,string>>.StaticMethod());
		cv1 :ConcreteVectorClass? = new ConcreteVectorClass(1,2.13f,3);
		cv2 :ConcreteVectorClass= cv1!;
		//print(i32(cv1! == cv2));
		//print(i32(cv1! != cv2));
		print((cv1 === cv2) as i32);
		print((cv1 !== cv2) as i32);
		mu: Next | f32 | str = new Next(5);
		print((mu as Next).i);
		if let cv11 := nxt as? Next 
		{
			print("aaaaaaaaaa");
		}
		media:Media = ::Audio("abcd",1,13);
		opt: ImportantOptions = {1,4,"abc"};
		ox, oy, oz := opt;
		print(ox);
		print(oy);
		print(oz);
		assert ox == 1;
		//assert(oz == "abc", "oz must be abcd");
		static assert(sizeof(i32) == 4, "i32 must be 4 bytes");
		//if (nxt is ConcreteVectorClass or i32) and (nxt2 is VectorClass) {
		x,y,z := vec;
		/*if vec is not null {
			print("Nxt2.ZZ = ");
			//print(nxt.i);
			//nxt2.ZZ = 10;
			print("Audio!");
		} else if vec is VectorClass {
            print("uz is incorrect");
		} else {
            print("uz is incorrect");
		}*/
		vec[1] = 5;
		print(cv1! as f32);
		print((cv1! is (cv2)) as i32);
		func := x => x*x;
		print(func(12));
		nx:= new Next(5);
		//nx.printNext();
		factorial: (x: i32) -> i32 
			=> x == 0 ? 1 : x * factorial(x-1);
		type SimpleAction = () -> void;
		
		print(vsum(1,2,3,4,5,6));

		//print(var.GetStrongReferenceCount());
		on: object? = vec;
	}
	print(nxt!.GetStrongReferenceCount());
	print(Test1.Test2.TestClass.makeTestClass(3,3.14f).x.x);
}
