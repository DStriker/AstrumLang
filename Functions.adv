package System.Application.Collections;

unsafe {
	volatile globalVar : *const char;
	let globalVar1 :*i32 = null;
	type cstring = *const byte;
}

@CLink
extern ExternalCounter: i32;

@CLink
@StdCall
extern externalFunc: (a: i32, b: str) -> str;

protected type Test111 = Test1.Test2.TestClass;
protected type Test112 = Test1.Test2.Class2;
public version WINDOWS = default 167;
protected version Linux = default true;

if debug {
NORMAL_CONSTANT :<T> T == 45;
INT_CONSTANT :== NORMAL_CONSTANT<i32>;
LONG_CONSTANT :== NORMAL_CONSTANT<i64>;
}

square: (a) ==> a * a;

printParams: (s: str, params: i32...) {
	print(s);
	for param in params {
		print(param);
	}
}

printParams: (s: str, params: str...) {
	for param in params {
		print(param);
	}
}

/*testt: (x: i32) -> (i: i32,t: Test1.Test2.TestClass,b: bool) {
//testt: (x: i32) -> Vector3 {
	i = x;
	//t = Test1.Test2.TestClass();
	b = true;
	return {i,t,b};
}*/

type SimpleTuple <A,C> = (A, bool, C);
type ImportantOptions = (i: i32,f: f64,s: str);

//sum: (in a, in b) ==> a + b;
sum: <T, U: i32> (a: T, b: T) -> forward;
sum<i32, 15>: (a: i32, b: i32) ==> a + b + 15;

public ref struct Span
{
	public &data: f32;
	public length: i32;
	inline ~this noexcept => print("Span deiniting");
}

public struct Vector3
{
	public {
		x, y, z: i32;
		//t: Test111 { get; private set; }

		//if debug _version: i32;
	}
	
	friend TestStruct;
	friend TestStruct2<T>;
	friend func3: (x: i32) -> i32;
	friend func4: (x: i32) -> i32 {
		return 0;
	}

	//public Equals: (in ref other: IEquatable) -> bool noexcept ==> true;
	public format: () -> str noexcept ==> "test";
	public HashCode: () -> usize ==> 654321u;
	public static AStaticMethod: (i: i32) -> i32 ==> i*2;

	public static Count: i32 = 1 {
		get {
			print("Read");
			return field * 10;
		}
		set {
			print("Write");
			@Likely
			if (value > 10) field = value / 10;
			else field = value;
		}
	}

	public Name: str ==> "Vector3";

	tls Count2: i32 = 123;
	BYTES :== 24;
	public static const ZERO :Vector3 = Vector3(0,0,0);
	type Coords = (x: i32,y: i32,z: i32);

	public class NestedStruct {
		public {
		x: f32;
		y: f32;
		z: f32;
		static count: (i: i32) -> i32 ==> i * 10;
		}
	}

	this() == default;
	implicit this(in ref that: self) == default;

	implicit this<U>(f: U) == {
		this(f,f,f);
		this.x = f;
	}

	inline ~this noexcept => print("Vector3 deiniting");

	public implicit operator f32 noexcept ==> y;

	public operator+: (in ref other: self) -> self => self(this.x + other.x, this.y + other.y, this.z + other.z);

	public mut operator++: () -> ref self = {
		++x;
		++y;
		++z;
		++Count;
		//t : Test111;
		//t = Test111();
		return this;
	}

	public this[idx: i32] -> f32 {
		get = {
			print("Read");
			return x;
		}
		public set = {
			if (value < 10) return;
			x = 5;
		}
	}
	public this[idx: i32, idx2: i32, idx3: i32] -> f32 ==> y + z;

	public getX: () -> f32 ==> x;
	extern getNext: () -> Next;

	public {
		inline static Method: (x: i32, y: i32, z: i32) -> i32 == {
			return y + z;
		}

		//GetMagicNumber: (i: f32) -> f32 ==> i * x;
		//DefaultMethod: (f: f32) -> f32 => f * 15;
		mut Reset: () == {
			x = 0;
			y = 0;
			z = 0;
		}

		//inline static GetTest: () -> Test111 ==> Test111();

		mut TemplateMethod: <U> (x: U, y: U, z: U) -> Coords == {
			struct LocalStruct {
				public {
				x: f32;
				y: f32;
				z: f32;
				//tt: Test111 { get; private set; }

				//if debug _version: i32;
				}
			}
			this[0] = 13;
			//print(this[0]);
			return {x,y,z};
		}
	}
}

public class BaseClass {
	public virtual getNext: () -> Next => new Next(5);
}

public abstract class VectorClass : BaseClass
{
	public {
		x, y, z: f32;
		//t: Test111 { get; private set; }

		//if debug _version: i32;
	}
	
	friend TestStruct;
	friend TestStruct2<T>;
	friend func3: (x: i32) -> i32;

	//public Equals: (in ref other: IEquatable) -> bool noexcept ==> true;
	public format: () -> str noexcept ==> "test";

	/*public static Count: i32 = 1 {
		get {
			print("Read");
			return field * 10;
		}
		private set {
			print("Write");
			if (value > 10) field = value / 10;
			else field = value;
		}
	}*/
	public abstract Count: i32 { get; set; }

	//public Name: str ==> "VectorClass";
	public abstract Name: str { get; set; }

	public static Count2: i32 = 123;
	public BYTES :== 24;
	public static const ZERO :Vector3 = Vector3(0,0,0);
	public type Coords = (x: i32,y: i32,z: i32);

	public class NestedClass {
		public {
		x: f32;
		y: f32;
		z: f32;

		this(x: f32, y: f32, z: f32) noexcept == {
			this.x = x;
			this.y = y;
			this.z = z;
		}
		static count: (i: i32) -> i32 ==> i * 10;
		}
	}

	protected this() == default;

	protected this(x: f32, y: f32, z: f32) noexcept == {
		this.x = x;
		this.y = y;
		this.z = z;
	}

	protected this<U>(f: U) == {
		this(f,f,f);
		this.x = f;
	}

	protected this(in other: self) = {
		this(other.x, other.y, other.z);
	}

	inline ~this noexcept => print("VectorClass deiniting");
	/*~this {
		print("VectorClass deiniting");
	}*/

	public operator f32 noexcept => y;

	/*public increment: () -> ref self = {
		++x;
		++y;
		++z;
		++Count;
		//t : Test111;
		//t = Test111();
		return this;
	}*/

	/*public mut operator++: () -> ref self = {
		++x;
		++y;
		++z;
		++Count;
		t : Test111;
		//t = Test111();
		return this;
	}*/

	/*public this[idx: i32] -> f32 {
		get = {
			print("Read");
			return x;
		}
		set = {
			print("Write");
			x = value;
		}
	}*/
	public this[idx: i32] -> ref f32 => x;
	public this[idx: i32, idx2: i32, idx3: i32] -> f32 => y + z;

	public abstract getX: () -> f32;
	public final getNext: () -> Next => super.getNext();

	public {
		inline static Method: (x: i32, y: i32, z: i32) -> i32 == {
			return y + z;
		}
		//DefaultMethod: (f: f32) -> f32 => f * 15;

		Reset: () == {
			x = 0;
			y = 0;
			z = 0;
		}

	//	inline static GetTest: () -> Test111 ==> Test111();

		TemplateMethod: <U> (x: U, y: U, z: U) -> Coords == {
			struct LocalStruct {
				public {
				x: f32;
				y: f32;
				z: f32;
				//tt: Test111 { get; private set; }

				//if debug _version: i32;
				}
			}
			this[0] = 13;
			//print(this[0]);
			return {x,y,z};
		}
	}
}


public class ConcreteVectorClass : VectorClass, IInterface {
	public type ElementType = i32;

	this() == default;

	public this(x: f32, y: f32, z: f32) noexcept == {
		super(x, y, z);
	}

	public implicit this(i: i32) noexcept == {
		super(f32(i), f32(i), f32(i));
	}

	public Name: str = "ConcreteVectorClass" { get; set; }

	public ZZ: i32 = 5 {get;set;}

	public final Count: i32 = 1 {
		get {
			print("Read");
			return field * 10;
		}
		private set {
			print("Write");
			if (value > 10) field = value / 10;
			else field = value;
		}
	}

	public Count123: i32 ==> 1500;

	public final getX: () -> f32 => x;

	operator+: (in ref other: ConcreteVectorClass) -> ConcreteVectorClass => new ConcreteVectorClass(this.x + other.x, this.y + other.y, this.z + other.z);
	GetMagicNumber: (in i: VectorClass) -> f32 => this.x * i.x;

	operator==: (in other: self) -> bool => x == other.x && y == other.y && z == other.z;

	public static AbstractStaticMethod: (i: i32) -> i32 ==> i*2;
	public static Name2: str ==> "abc";

}
//public GetMagicNumber: (in vec: VectorClass, i: VectorClass) -> f32 => vec.y * i.y;
//public GetMagicNumber: (in vec: ConcreteVectorClass, in i: VectorClass) -> f32 => vec.x * i.x;

public _operator_subscript: (in vec: VectorClass, x: f32, y: f32) -> f32 => vec.x * x + vec.y * y;

public class Next {
	public i: i32;
	public weak v: Next?;

	this() = default;

	~this => print("Next deiniting");

	public this(i: i32) = {
		this.i = i;
		//this.v = new Next(this);
	}

	public this(in other: self) = {
		this.i = 0;
		//this.v = other;
	}
	public operator!: () -> i32 => i;

	public printNext: () = {
		func2 := [weak this] (x: i32, y: i32) -> i32 { j:= x*y*this!.i; return j*2; };
		print("This is printNext function in optional chaining call");
		print(func2(3,4));
	}
}

public extension Next {
	TestInt:(j: i32) -> i32 ==> this.i+j*2;
}

public interface IMagicNumber {
	GetMagicNumber: (in f: VectorClass) -> f32;
	Count123: i32 { get; }
}

public interface IResettable {
	Reset: ();
}

public interface IInterface: IMagicNumber, IResettable {
	VERSION :== 12345;
	type ElementType;
	type SomeInt = i32;

	final DefaultMethod: (in f: VectorClass) -> f32 => this.GetMagicNumber(f);
	operator+: (in ref f: ConcreteVectorClass) -> ConcreteVectorClass;
	
	Name: str { get; }
	static Name2: str;
	this[i: i32] -> ref f32 { get; }

	static AbstractStaticMethod: (i: i32) -> i32;
	static final SomeStaticMethod: (i: i32) -> i32 ==> i * 123;
}

public enum DayOfWeek {
	Monday = 1,
	Tuesday,
	Wednesday,
	Thursday,
	Friday,
	Saturday,
	Sunday
}

@Flags
public enum Options : u8 {
	None = 0,
	First,//1
	Second,//2
	Third,//4
	Fourth,//8
	Fiveth,//16
	Sixth,//32
	Seventh,//64

    All = First | Second | Third | Fourth | Fiveth | Sixth | Seventh,
	Weekend = Sixth | Seventh;

	IsWeekend: bool => Weekend.HasFlag(this);
}
public enum Text : str {
	Monday = "This is Monday",
	Tuesday = "This is Tuesday",
	Wednesday = "This is Wednesday",
	Thursday = "This is Thursday",
	Friday = "This is Friday",
	Saturday = "This is Saturday",
	Sunday = "This is Sunday";

	public ToShortString: () -> str = {
		return Value;
	}
	private ShortString: str => Value;
}

public enum class ComplexVariant {
	Value1(1, 2.13f, "Value1"),
	Value2(2, 4.13f, "Value2"),
	Value3(3, 6.13f, "Value3"),
	Value4(4, 8.13f, "Value4");

	public {
		i: i32;
		f: f32;
		s: str;
	}

	public operator!: () -> i32 => i;

	public printVariant: () = {
		print("This is printVariant function in optional chaining call");
		print(s);
	}

    public GetMagicNumber: (in f: VectorClass) -> f32 => this.f * f.x;

	public Count123: i32 ==> 1234567890;

	public static Count10: i32 ==> 12345;
}

public union Media : IMagicNumber {
	None,
	String(str),
	XYZ(i32,i32,i32),
    Audio(name: str, len: i32, volume: f32),
    Video(name: str, len: i32, fps: f32, lang: str),
	Text(lang: str);

	public printVariant: () = {
		print("This is printVariant function in Media union");
	}

    public GetMagicNumber: (in f: VectorClass) -> f32 => 0.5f * f.x;

	public Count123: i32 ==> 1234567890;

	public static Count10: i32 ==> 12345;
}

public union<T1, T2> Union2 {
	Type1(T1),
	Type2(T2)
}

public union<T1, T2, T3> Union3 {
	Type1(T1),
	Type2(T2),
	Type3(T3)
}

public union<T1, T2, T3, T4> Union4 {
	Type1(T1),
	Type2(T2),
	Type3(T3),
	Type4(T4)
}

public union<T1, T2, T3, T4, T5> Union5 {
	Type1(T1),
	Type2(T2),
	Type3(T3),
	Type4(T4),
	Type5(T5)
}

public union<T1, T2, T3, T4, T5, T6> Union6 {
	Type1(T1),
	Type2(T2),
	Type3(T3),
	Type4(T4),
	Type5(T5),
	Type6(T6)
}

private extension <T> {
	AsString: str => "AsString";

    operator*: (in f: f32) -> f32 => f * 10;

	PrintInterface: (x: i32) -> i32 = {
		print("PrintInterface Begin");
		print(this.Name);
		print(x);
		print("PrintInterface End");
		return x * 11;
	}

	this[r: f32, g: f32, b: f32] -> f32 => r + g + b;

	this(x: i32, txt: str) = {
		this(x, x, x);
        print(txt);
	}

	this(mem: CppAdvance.MemorySpace, x: i32, txt: str) = {
		this(x, x, x);
        print(txt);
	}

	//operator+: (in ref other: ConcreteVectorClass) -> ConcreteVectorClass => new ConcreteVectorClass(this.x + other.x, this.y + other.y, this.z + other.z);
	//GetMagicNumber: (in i: VectorClass) -> f32 => this.x * i.x;
}

public extension <T> {
	static Count3: i32 ==> 333;
	static GetSuperCount: (x: i32, y: i32) -> i32 ==> x*y + x+y;
}

public extension <T> where type T is i32 {
	km: i32 ==> this * 1000;

	@AllowPostfix
	operator \*/: () -> i32 ==> this / 2;

	@Commutative
	operator \*/: (other: f32) -> f32 ==> f32(this) * other * 2;
}

public extension f64 {
	km: f64 ==> this * 1000.0f;
}

public extension str {
	km: str ==> "1000km";
}

public getSum: (in vec: VectorClass) -> f32 => vec.x + vec.y + vec.z;

@Align(alignof(i64))
@Packed
struct TestStruct {
	x: System.CInt : 4;
	y: System.CInt : 4;
	
	static assert(sizeof(i32) == 4, "i32 must be 4 bytes");
}

ttest: <T1, T2> (x: T1, y: T2) -> i32 => T2.GetInt();


vsum: <TArgs...> (forward args: TArgs...) 
	=> (args + ... + 1);

type Action<Args...> = (Args...) -> void;
type Predicate<T> = (T) -> bool;

private {
	PRIVATE_CONSTANT : usize == 34;
	globalVar2 :i32 = 8;
	let globalVar3 :i32 = 456;
	//xyz :IntArray = {{{1,2,3},{4,5,6},{7,8,9}},{{11,12,13},{14,15,16},{17,18,19}},{{21,22,23},{24,25,26},{27,28,29}}};
	//type IntArray = i64[3][3][3];
}

public extension Vector3
{
	getNext: () -> Next => new Next(this.x);
}

test "main module test"
{
	opt: ImportantOptions = {1,4,"abc"};
	ox, oy, oz := opt;
	assert ox == 11;
}
